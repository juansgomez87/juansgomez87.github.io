<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISMIR25Viz - Interactive Paper Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #8e2038 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 20px auto;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 1600px;
            width: calc(100% - 40px);
        }

        .header h1 {
            font-size: 2.2em;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .container {
            display: flex;
            gap: 20px;
            padding: 0 20px 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .left-sidebar {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .right-sidebar {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .controls h3 {
            margin-bottom: 20px;
            font-size: 1.3em;
            color: #333;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.8em;
        }

        .control-group select, .control-group input[type="text"] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            background: white;
            transition: all 0.3s ease;
        }

        .control-group select:hover, .control-group input[type="text"]:hover {
            border-color: #667eea;
        }

        .control-group select:focus, .control-group input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-group {
            position: relative;
            margin-bottom: 20px;
        }

        .search-group input {
            padding-right: 40px;
        }

        .advanced-search {
            background: #f8fafc;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .advanced-search .field {
            margin-bottom: 10px;
        }

        .year-range {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .range-slider {
            position: relative;
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            margin: 10px 0;
        }

        .range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 6px;
            background: none;
            pointer-events: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        .range-slider input[type="range"]::-webkit-slider-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            pointer-events: all;
            -webkit-appearance: none;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .range-slider input[type="range"]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            pointer-events: all;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .reset-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #f56565, #e53e3e);
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 12px;
        }

        .tag {
            padding: 4px 10px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .tag:hover {
            border-color: #667eea;
        }

        .tag.more-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            font-weight: 600;
            font-style: italic;
        }

        .tag.more-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .timeline {
            height: 200px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        #plotDiv {
            width: 100%;
            height: 70vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .paper-info {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            flex: 1;
            height: fit-content;
            max-height: 90vh;
        }

        .paper-info h4 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        .paper-info p {
            margin-bottom: 12px;
            line-height: 1.5;
            color: #555;
        }

        .paper-info .abstract {
            background: #f8fafc;
            padding: 15px;
            border-left: 4px solid #667eea;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .paper-info a {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
            padding: 10px 16px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .paper-info a:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
        }

        .paper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }

        .paper-header h4 {
            margin: 0;
            flex: 1;
        }

        .view-paper-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }

        .view-paper-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .translate-widget {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 20px;
            border-radius: 16px;
            margin: 15px 0;
            border: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        .translate-widget::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);
            border-radius: 16px 16px 0 0;
        }

        .translate-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .translate-icon {
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .translate-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .translate-controls select {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 13px;
            background: white;
            color: #374151;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            min-width: 140px;
        }

        .translate-controls select:hover {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .translate-controls select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .translate-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .translate-btn:hover {
            background: linear-gradient(45deg, #1d4ed8, #1e40af);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .translate-btn:active {
            transform: translateY(0);
        }

        .translate-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .translated-text {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            margin-top: 12px;
            font-size: 0.9em;
            line-height: 1.6;
            border: 1px solid rgba(59, 130, 246, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .translate-loading {
            color: #6b7280;
            font-style: italic;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 0;
        }

        .translate-loading::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .translation-disclaimer {
            margin-top: 12px;
            padding: 10px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 8px;
            font-size: 0.8em;
            color: #92400e;
            border-left: 3px solid #f59e0b;
        }

        .translation-fallback {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 1px solid #f59e0b;
            border-radius: 12px;
            padding: 16px;
        }

        .fallback-button {
            background: linear-gradient(45deg, #f59e0b, #d97706);
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin: 8px 0;
        }

        .fallback-button:hover {
            background: linear-gradient(45deg, #d97706, #b45309);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .copy-section {
            margin-top: 12px;
            border-top: 1px solid #e5e7eb;
            padding-top: 12px;
        }

        .copy-section summary {
            cursor: pointer;
            font-weight: 600;
            color: #374151;
            padding: 8px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .copy-section summary:hover {
            color: #3b82f6;
        }

        .copy-text-area {
            background: #f9fafb;
            padding: 12px;
            margin-top: 8px;
            border-radius: 8px;
            font-size: 0.9em;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
        }

        .show-more-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .show-more-btn:hover {
            background: linear-gradient(45deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .show-more-btn:active {
            transform: translateY(0);
        }

        .stats {
            background: #f8fafc;
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
            border-left: 4px solid #10b981;
        }

        .stats strong {
            color: #065f46;
        }

        .loading {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 18px;
            color: #666;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .left-sidebar, .right-sidebar {
                flex: none;
            }
            
            #plotDiv {
                height: 70vh;
            }
            
            .paper-info {
                max-height: 40vh;
            }
        }

        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .radio-option:hover {
            border-color: #667eea;
        }

        .radio-option input[type="radio"] {
            margin: 0;
        }

        .radio-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 5px;
            background: #f8fafc;
            border-radius: 12px;
        }

        .view-option {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
        }

        .view-option.active {
            background: #667eea;
            color: white;
        }

        .view-option:not(.active) {
            background: white;
            color: #666;
        }

        .view-option:hover:not(.active) {
            background: #e2e8f0;
        }

        .evolution-controls {
            background: #f8fafc;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #10b981;
        }

        .evolution-timeline {
            height: 300px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .keyword-trends {
            height: 400px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Beyond a western center of MIR: ISMIR25Viz</h1>
        <!-- <p style="font-size: 13px; line-height: 1.4;">
            Over the past two decades, the Music Information Retrieval (MIR) community has grown significantly in both the volume and diversity of research contributions.
            However, questions remain about who is represented within the communityâ€”and who is not.
            The influence of Western, Educated, Industrialized, Rich, and Democratic (WEIRD) science shapes MIR research, affecting topic selection, cross-cultural considerations, and reproducibility.
            While discussions on the impact of the WEIRD framework have gained traction in adjacent fields, there remains a need to critically assess its presence and limitations within MIR.
            This study analyzes the corpus of 2,458 ISMIR conference papers (2000â€“2024) to examine the geographic and institutional distribution of authors.
            Our findings indicate that ISMIR research remains Western-centric, with disproportionate representation from the Global North alongside increasing cross-institutional collaborations.
            In addition to bibliometric insights, we provide an aggregated dataset <strong>ISMIR25Meta</strong>, a novel topic-based visualizer <strong>ISMIR25Viz</strong>, and recommendations for fostering a more inclusive MIR community.
        </p> -->
    </div>

    <div class="container">
        <div class="left-sidebar">
            <div class="controls">
                <h3>Visualization Controls</h3>
                <button onclick="window.explorer.resetFilters()" class="reset-button">
                    Reset All
                </button>
                
                <div id="scatterControls">
                    <div class="advanced-search">
                        <div class="field">
                            <label for="titleSearch">Title:</label>
                            <input type="text" id="titleSearch" placeholder="Search in titles...">
                        </div>
                        <div class="field">
                            <label for="authorSearch">Authors:</label>
                            <input type="text" id="authorSearch" placeholder="Search authors...">
                        </div>
                        <div class="field">
                            <label>Year Range:</label>
                            <div class="year-range">
                                <div class="range-slider">
                                    <input type="range" id="yearStart" min="2000" max="2024" value="2000" step="1">
                                    <input type="range" id="yearEnd" min="2000" max="2024" value="2024" step="1">
                                </div>
                                <div class="range-values">
                                    <span id="yearStartValue">2000</span>
                                    <span id="yearEndValue">2024</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="tag-cloud" id="tagCloud">
                        <!-- Tags will be dynamically added here -->
                    </div>
                    
                    <div class="control-group">
                        <label>Dimensionality Reduction:</label>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="method" value="tsne">
                                t-SNE
                            </label>
                            <label class="radio-option selected">
                                <input type="radio" name="method" value="umap" checked>
                                UMAP
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Plot Dimensionality:</label>
                        <div class="radio-group">
                            <label class="radio-option selected">
                                <input type="radio" name="dimension" value="2d" checked>
                                2D View
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="dimension" value="3d">
                                3D View
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Embedding Source:</label>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="embedding" value="title">
                                Titles
                            </label>
                            <label class="radio-option selected">
                                <input type="radio" name="embedding" value="abstract" checked>
                                Abstracts
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Color By:</label>
                        <div class="radio-group">
                            <label class="radio-option selected">
                                <input type="radio" name="colorBy" value="Year" checked>
                                Year
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="colorBy" value="first_country">
                                Country
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="colorBy" value="first_aff_cat">
                                Affiliation
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="colorBy" value="first_aff_cat_UN">
                                UN Categories
                            </label>
                        </div>
                    </div>
                </div>

                <div id="evolutionControls" style="display: none;">
                    <div class="evolution-controls">
                        <div class="field">
                            <label for="evolutionKeywords">Select Research Topics to Track (up to 12):</label>
                            <div id="evolutionKeywordSelector" class="tag-cloud">
                                <!-- Evolution keywords will be added here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="view-toggle">
                <button class="view-option active" onclick="window.explorer.switchView('scatter')">
                    ðŸ“Š Scatter Plot View
                </button>
                <button class="view-option" onclick="window.explorer.switchView('evolution')">
                    ðŸ“ˆ Research Evolution
                </button>
            </div>

            <div id="scatterView">
                <div id="plotDiv">
                    <div id="loadingSpinner" class="loading">
                        <div class="loading-spinner"></div>
                        <div>Loading visualization...</div>
                    </div>
                </div>
            </div>

            <div id="evolutionView" style="display: none;">
                <div class="keyword-trends" id="keywordTrends"></div>
            </div>
        </div>
        
        <div class="right-sidebar">
            <div class="paper-info" id="paperInfo">
                <h4>ðŸ“„ Paper Details</h4>
                <p>Click on any point in the visualization to explore paper details, abstracts, and author information.</p>
                <div class="stats">
                    <strong>Interactive Features:</strong><br>
                    â€¢ Hover for quick info<br>
                    â€¢ Click for detailed view<br>
                    â€¢ Zoom and pan to explore<br>
                    â€¢ Switch between 2D/3D views
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * N-GRAM EXTRACTION DOCUMENTATION
         * ===============================
         * 
         * The n-gram extraction system works as follows:
         * 
         * 1. SOURCE DATA:
         *    - Extracts n-grams from paper titles only
         *    - Generates both bi-grams (2-word phrases) and tri-grams (3-word phrases)
         *    - Examples: "deep learning", "neural network", "music information retrieval"
         * 
         * 2. EXTRACTION PROCESS:
         *    - Converts text to lowercase and removes punctuation
         *    - Splits into individual words and filters stop words
         *    - Creates sliding windows of 2 and 3 words
         *    - Filters out n-grams containing only stop words
         *    - Joins words with spaces to create phrases
         * 
         * 3. STOP WORDS:
         *    - Common words and domain-specific terms are filtered
         *    - N-grams must contain at least one meaningful word
         *    - This helps surface coherent research topics
         * 
         * 4. RANKING & SELECTION:
         *    - Counts frequency of each n-gram across all paper titles
         *    - Sorts by frequency (most common first)
         *    - Stores top 60 n-grams, initially showing 20 for scatter and 30 for evolution
         * 
         * 5. FILTERING BEHAVIOR:
         *    - When n-grams are selected, papers must contain the exact phrase in titles
         *    - Search is case-insensitive
         *    - Both scatter and evolution views use title-based n-grams
         */

        class ISMIRExplorer {
            constructor() {
                this.data = null;
                this.unCategories = null;
                this.currentPlot = null;
                this.filteredData = null;
                this.selectedTags = new Set();
                this.commonKeywords = null;
                this.currentView = 'scatter';
                this.evolutionKeywords = new Set();
                this.topicEvolution = null;
                this.scatterTagsVisible = 10;
                this.evolutionTagsVisible = 30;
            }

            async init() {
                try {
                    // Hide loading spinner immediately
                    const loadingSpinner = document.getElementById('loadingSpinner');
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    
                    // First load the data
                    await this.loadData();
                    
                    // Then process it
                    if (this.data) {
                        this.processData();
                        
                        // Set initial filtered data to all data
                        this.filteredData = this.data;
                        
                        // Generate tag cloud and setup event listeners
                        this.generateTagCloud();
                        this.setupEventListeners();
                        
                        // Finally update the plot
                        requestAnimationFrame(() => {
                            this.updatePlot();
                        });
                    }
                } catch (error) {
                    console.error('Initialization failed:', error);
                    const plotDiv = document.getElementById('plotDiv');
                    if (plotDiv) {
                        this.showError('Failed to initialize application', error.message);
                    }
                }
            }

            async loadData() {
                try {
                    if (window.location.protocol !== 'file:') {
                        try {
                            const [dataResponse, unResponse] = await Promise.all([
                                fetch('data/ismir_all_papers.json'),
                                fetch('data/UN_categorization.json')
                            ]);

                            if (dataResponse.ok && unResponse.ok) {
                                const [dataJson, unJson] = await Promise.all([
                                    dataResponse.json(),
                                    unResponse.json()
                                ]);

                                this.data = dataJson;
                                this.unCategories = unJson;
                                this.processData();
                                return;
                            }
                        } catch (fetchError) {
                            console.warn('JSON fetch failed:', fetchError);
                        }
                    }

                    if (window.location.protocol !== 'file:') {
                        try {
                            const [csvResponse, unResponse] = await Promise.all([
                                fetch('data/ismir_all_papers.csv'),
                                fetch('data/UN_categorization.csv')
                            ]);

                            if (csvResponse.ok && unResponse.ok) {
                                const [csvText, unText] = await Promise.all([
                                    csvResponse.text(),
                                    unResponse.text()
                                ]);

                                this.data = Papa.parse(csvText, { 
                                    header: true, 
                                    skipEmptyLines: true,
                                    dynamicTyping: true,
                                    trimHeaders: true
                                }).data;
                                
                                this.unCategories = Papa.parse(unText, { 
                                    header: true, 
                                    skipEmptyLines: true,
                                    trimHeaders: true
                                }).data;

                                this.processData();
                                return;
                            }
                        } catch (csvError) {
                            console.warn('CSV fetch failed:', csvError);
                        }
                    }

                    console.log('Using sample data for demonstration');
                    this.data = window.SAMPLE_DATA;
                    this.unCategories = window.SAMPLE_UN_DATA;
                    this.processData();
                    this.showSampleDataWarning();

                } catch (error) {
                    console.error('Data loading error:', error);
                    this.showFileUploadInterface(error.message);
                }
            }

            processData() {
                console.log('Processing data...');
                
                const unMap = {};
                if (this.unCategories) {
                    this.unCategories.forEach(row => {
                        const isoCode = row['ISO Code'] || row['ISO'] || row['Code'];
                        const category = row['Economic Category'] || row['Category'] || row['UN Category'];
                        if (isoCode && category) {
                            unMap[isoCode.trim()] = category.trim();
                        }
                    });
                }

                if (!this.data) return;

                this.data = this.data.filter(row => row.Abstract && row.Abstract.trim() && row.Abstract !== '""');
                this.filteredData = this.data;
                
                this.data.forEach((row, index) => {
                    row.point_index = index;
                    
                    if (row['Authors with Affiliations']) {
                        const affiliations = row['Authors with Affiliations'].split(';');
                        const countries = affiliations
                            .map(aff => aff.split('>')[1])
                            .filter(c => c && c.trim());
                        const affTypes = affiliations
                            .map(aff => aff.split('>').pop())
                            .filter(t => t && t.trim());
                        
                        row['Affiliation country'] = countries.join(', ');
                        row['Affiliation type'] = affTypes.join(', ');
                        row['first_country'] = countries[0]?.trim() || 'Unknown';
                        row['first_aff_cat'] = affTypes[0]?.trim() || 'Unknown';
                        
                        const unCats = countries.map(country => {
                            const cleanCountry = country?.trim();
                            return unMap[cleanCountry] || 'Unknown';
                        });
                        row['UN Categories'] = unCats.join(', ');
                        row['first_aff_cat_UN'] = unCats[0] || 'Unknown';
                    } else {
                        row['first_country'] = 'Unknown';
                        row['first_aff_cat'] = 'Unknown';
                        row['first_aff_cat_UN'] = 'Unknown';
                    }
                    
                    const coordCols = [
                        'title_tsne_2d', 'title_tsne_3d', 'title_umap_2d', 'title_umap_3d',
                        'abstract_tsne_2d', 'abstract_tsne_3d', 'abstract_umap_2d', 'abstract_umap_3d'
                    ];
                    
                    coordCols.forEach(col => {
                        if (row[col] && row[col] !== null && row[col] !== '') {
                            try {
                                let coordStr = row[col].toString().trim();
                                // Handle different possible formats
                                if (coordStr.startsWith('[') && coordStr.endsWith(']')) {
                                    row[col] = JSON.parse(coordStr);
                                } else if (coordStr.includes(',')) {
                                    // Handle comma-separated values
                                    row[col] = coordStr.split(',').map(x => parseFloat(x.trim()));
                                } else {
                                    // Skip if it's not a valid coordinate format
                                    row[col] = null;
                                }
                                
                                // Validate that we have valid numbers
                                if (Array.isArray(row[col]) && row[col].some(x => isNaN(x))) {
                                    row[col] = null;
                                }
                            } catch (e) {
                                // Only log if it's not just an empty/null value
                                if (row[col] && row[col].toString().trim() !== '') {
                                    console.warn(`Failed to parse coordinates for ${col} in row ${index}:`, row[col]);
                                }
                                row[col] = null;
                            }
                        } else {
                            row[col] = null;
                        }
                    });
                });

                console.log(`Processed ${this.data.length} papers`);
            }

            setupEventListeners() {
                // Setup radio button listeners
                const radioGroups = ['method', 'dimension', 'embedding', 'colorBy'];
                radioGroups.forEach(groupName => {
                    const radios = document.querySelectorAll(`input[name="${groupName}"]`);
                    radios.forEach(radio => {
                        radio.addEventListener('change', () => {
                            // Update visual selection
                            document.querySelectorAll(`input[name="${groupName}"]`).forEach(r => {
                                r.closest('.radio-option').classList.remove('selected');
                            });
                            radio.closest('.radio-option').classList.add('selected');
                            
                            // Update plot
                            this.updatePlot();
                        });
                    });
                });

                // Add event listeners for search inputs with auto-filtering
                const searchInputs = ['titleSearch', 'authorSearch'];
                searchInputs.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.applyFilters();
                        });
                        element.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') {
                                this.applyFilters();
                            }
                        });
                    }
                });

                // Setup range sliders with auto-filtering
                const yearStartSlider = document.getElementById('yearStart');
                const yearEndSlider = document.getElementById('yearEnd');
                const yearStartValue = document.getElementById('yearStartValue');
                const yearEndValue = document.getElementById('yearEndValue');

                if (yearStartSlider && yearEndSlider) {
                    yearStartSlider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        const endValue = parseInt(yearEndSlider.value);
                        
                        if (value > endValue) {
                            yearEndSlider.value = value;
                            yearEndValue.textContent = value;
                        }
                        
                        yearStartValue.textContent = value;
                        this.applyFilters(); // Auto-filter on change
                    });

                    yearEndSlider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        const startValue = parseInt(yearStartSlider.value);
                        
                        if (value < startValue) {
                            yearStartSlider.value = value;
                            yearStartValue.textContent = value;
                        }
                        
                        yearEndValue.textContent = value;
                        this.applyFilters(); // Auto-filter on change
                    });
                }
            }

            updatePlot() {
                if (!this.filteredData || this.filteredData.length === 0) {
                    this.showError('No data available', 'No papers match the current filters');
                    return;
                }

                const method = document.querySelector('input[name="method"]:checked')?.value || 'umap';
                const dim = document.querySelector('input[name="dimension"]:checked')?.value || '2d';
                const embedding = document.querySelector('input[name="embedding"]:checked')?.value || 'abstract';
                const colorBy = document.querySelector('input[name="colorBy"]:checked')?.value || 'Year';
                
                const coordCol = `${embedding}_${method}_${dim}`;
                
                const validData = this.filteredData.filter(row => 
                    row[coordCol] && Array.isArray(row[coordCol]) && row[coordCol].length >= (dim === '2d' ? 2 : 3)
                );
                
                if (validData.length === 0) {
                    this.showError('No valid coordinates found', `No papers with valid coordinates match the current filters`);
                    return;
                }
                
                const groups = {};
                validData.forEach(row => {
                    const key = row[colorBy] || 'Unknown';
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(row);
                });
                
                const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#ffecd2', '#fcb69f'];
                
                const traces = Object.entries(groups).map(([key, group], index) => {
                    const coords = group.map(row => row[coordCol]);
                    const texts = group.map(row => 
                        `<b>${row.Title || 'Unknown'}</b><br>` +
                        `Year: ${row.Year || 'Unknown'}<br>` +
                        `Authors: ${(row.Authors || 'Unknown').substring(0, 100)}${row.Authors && row.Authors.length > 100 ? '...' : ''}<br>` +
                        `Country: ${row.first_country || 'Unknown'}<br>` +
                        `Click for details`
                    );
                    
                    const baseTrace = {
                        mode: 'markers',
                        name: `${key} (${group.length})`,
                        text: texts,
                        hoverinfo: 'text',
                        hovertemplate: '%{text}<extra></extra>',
                        marker: {
                            size: dim === '2d' ? 8 : 5,
                            opacity: 0.7,
                            color: colors[index % colors.length],
                            line: { width: 1, color: 'white' }
                        }
                    };
                    
                    if (dim === '2d') {
                        return {
                            ...baseTrace,
                            x: coords.map(c => c[0]),
                            y: coords.map(c => c[1]),
                            type: 'scattergl'
                        };
                    } else {
                        return {
                            ...baseTrace,
                            x: coords.map(c => c[0]),
                            y: coords.map(c => c[1]),
                            z: coords.map(c => c[2]),
                            type: 'scatter3d'
                        };
                    }
                });
                
                const layout = {
                    title: {
                        text: `${method.toUpperCase()} embeddings of ${embedding}s`,
                        font: { size: 16, color: '#333' }
                    },
                    margin: { l: 50, r: 50, b: 50, t: 60 },
                    legend: { 
                        orientation: 'h',
                        x: 0,
                        y: -0.1,
                        font: { size: 12 }
                    },
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)'
                };
                
                if (dim === '3d') {
                    layout.scene = {
                        xaxis: { title: 'Dimension 1' },
                        yaxis: { title: 'Dimension 2' },
                        zaxis: { title: 'Dimension 3' },
                        bgcolor: 'rgba(0,0,0,0)'
                    };
                }
                
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };
                
                Plotly.newPlot('plotDiv', traces, layout, config);
                
                document.getElementById('plotDiv').on('plotly_click', (data) => {
                    this.handlePlotClick(data, validData);
                });

                this.updateStats(validData.length, this.data.length);
            }

            handlePlotClick(data, validData) {
                if (!data.points || data.points.length === 0) return;
                
                const point = data.points[0];
                const traceIndex = point.curveNumber;
                const pointIndex = point.pointIndex;
                
                const traces = document.getElementById('plotDiv').data;
                const traceName = traces[traceIndex].name.split(' (')[0];
                
                const groupPapers = validData.filter(row => {
                    const colorBy = document.querySelector('input[name="colorBy"]:checked')?.value || 'Year';
                    return (row[colorBy] || 'Unknown') === traceName;
                });
                
                if (groupPapers[pointIndex]) {
                    this.showPaperInfo(groupPapers[pointIndex]);
                }
            }

            showPaperInfo(paper) {
                if (!paper) return;
                
                // Store the full abstract for translation
                this.currentPaperAbstract = paper.Abstract || 'No abstract available';
                
                const infoDiv = document.getElementById('paperInfo');
                
                let countryHtml = '';
                if (paper['Affiliation country']) {
                    const countries = paper['Affiliation country'].split(', ');
                    const countryCounts = {};
                    countries.forEach(country => {
                        const clean = country.trim();
                        countryCounts[clean] = (countryCounts[clean] || 0) + 1;
                    });
                    
                    countryHtml = `
                        <div class="stats">
                            <strong>ðŸŒ Author Countries:</strong><br>
                            ${Object.entries(countryCounts)
                                .map(([country, count]) => `${country}: ${count} author${count > 1 ? 's' : ''}`)
                                .join('<br>')}
                        </div>
                    `;
                }
                
                let abstract = paper.Abstract || 'No abstract available';
                const fullAbstract = abstract;
                const isAbstractTruncated = abstract.length > 500;
                if (isAbstractTruncated) {
                    abstract = abstract.substring(0, 500);
                }
                
                infoDiv.innerHTML = `
                    <div class="paper-header">
                        <h4>ðŸ“„ Paper Details</h4>
                        ${paper.Link ? `
                            <a href="${paper.Link}" target="_blank" rel="noopener noreferrer" class="view-paper-btn">
                                View Full Paper
                            </a>
                        ` : ''}
                    </div>
                    <p><strong>Title:</strong> ${paper.Title || 'Unknown'}</p>
                    <p><strong>Year:</strong> ${paper.Year || 'Unknown'}</p>
                    <p><strong>Authors:</strong> ${paper.Authors || 'Unknown'}</p>
                    
                    <div class="abstract">
                        <strong>Abstract:</strong><br>
                        <div id="originalAbstract">
                            ${abstract}${isAbstractTruncated ? `
                                <span id="abstractTruncated">...</span>
                                <span id="abstractFull" style="display: none;">${fullAbstract.substring(500)}</span>
                                <br><br>
                                <button class="show-more-btn" onclick="window.explorer.toggleAbstract()">
                                    Show full abstract
                                </button>
                            ` : ''}
                        </div>
                        
                        <div class="translate-widget">
                            <div class="translate-header">
                                <div class="translate-icon">ðŸŒ</div>
                                <span>Translation</span>
                            </div>
                            <div class="translate-controls">
                                <select id="targetLanguage">
                                    <option value="es">Spanish</option>
                                    <option value="zh">Chinese (Mandarin)</option>
                                    <option value="hi">Hindi</option>
                                    <option value="ar">Arabic</option>
                                    <option value="pt">Portuguese</option>
                                    <option value="bn">Bengali</option>
                                    <option value="ru">Russian</option>
                                    <option value="ja">Japanese</option>
                                    <option value="ur">Urdu</option>
                                    <option value="id">Indonesian</option>
                                    <option value="sw">Swahili</option>
                                    <option value="te">Telugu</option>
                                    <option value="mr">Marathi</option>
                                    <option value="ta">Tamil</option>
                                    <option value="tr">Turkish</option>
                                    <option value="ko">Korean</option>
                                    <option value="vi">Vietnamese</option>
                                    <option value="th">Thai</option>
                                    <option value="gu">Gujarati</option>
                                    <option value="fa">Persian (Farsi)</option>
                                    <option value="ms">Malay</option>
                                    <option value="kn">Kannada</option>
                                    <option value="ml">Malayalam</option>
                                    <option value="pa">Punjabi</option>
                                    <option value="or">Odia</option>
                                    <option value="as">Assamese</option>
                                    <option value="ne">Nepali</option>
                                    <option value="si">Sinhala</option>
                                    <option value="my">Myanmar (Burmese)</option>
                                    <option value="km">Khmer (Cambodian)</option>
                                    <option value="lo">Lao</option>
                                    <option value="am">Amharic</option>
                                    <option value="ha">Hausa</option>
                                    <option value="fr">French</option>
                                    <option value="de">German</option>
                                    <option value="it">Italian</option>
                                    <option value="nl">Dutch</option>
                                    <option value="sv">Swedish</option>
                                </select>
                                <button class="translate-btn" onclick="window.explorer.translateAbstract()">
                                    Translate
                                </button>
                            </div>
                            <div id="translatedAbstract"></div>
                        </div>
                    </div>
                    
                    ${countryHtml}
                `;
            }

            updateStats(validCount, totalCount) {
                const titleSearch = document.getElementById('titleSearch');
                const searchTerm = titleSearch ? titleSearch.value.trim() : '';
                const statsInfo = document.querySelector('.paper-info .stats');
                
                if (statsInfo) {
                    statsInfo.innerHTML = `
                        <strong>ðŸ“Š Dataset Stats:</strong><br>
                        â€¢ ${validCount} papers visualized${searchTerm ? ` (filtered by "${searchTerm}")` : ''}<br>
                        â€¢ 2458 total papers<br>
                        â€¢ ${Math.round((validCount/2458) * 100)}% of total papers
                    `;
                }
            }

            showError(title, message) {
                const plotDiv = document.getElementById('plotDiv');
                if (plotDiv) {
                    plotDiv.innerHTML = `
                        <div class="error">
                            <h3>${title}</h3>
                            <p>${message}</p>
                            <button onclick="location.reload()" class="load-button">
                                ðŸ”„ Reload Page
                            </button>
                        </div>
                    `;
                }
            }

            extractNGrams(text, n = 2) {
                const stopWords = new Set([
                    'and', 'or', 'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with',
                    'that', 'this', 'from', 'audio', 'musical', 'using', 'model', 'paper',
                    'which', 'results', 'automatic', 'data', 'based', 'models',  
                    'approach', 'modeling', 'song', 'system', 'towards', 
                    'analysis', 'method', 'algorithm', 'feature', 'features', 
                ]);

                // N-grams to filter out (meaningless phrases)
                const stopNGrams = new Set([
                    // Common meaningless bi-grams
                    'for music', 'music for', 'of music', 'music of', 'in music', 'music in',
                    'to music', 'music to', 'with music', 'music with', 'and music', 'music and',
                    'information retrieval', 'retrieval information', 'retrieval system', 'system retrieval',
                    'music retrieval', 'retrieval music', 'audio retrieval', 'retrieval audio',
                    'music information', 'information music', 'audio information', 'information audio',
                    'music system', 'system music', 'audio system', 'system audio',
                    'music analysis', 'analysis music', 'audio analysis', 'analysis audio',
                    'music classification', 'classification music', 'audio classification', 'classification audio',
                    'music detection', 'detection music', 'audio detection', 'detection audio',
                    'music recognition', 'recognition music', 'audio recognition', 'recognition audio',
                    'music research', 'research music', 'audio research', 'research audio',
                    'music paper', 'paper music', 'audio paper', 'paper audio',
                    'music work', 'work music', 'audio work', 'work audio',
                    'music task', 'task music', 'audio task', 'task audio',
                    'music problem', 'problem music', 'audio problem', 'problem audio',
                    'music application', 'application music', 'audio application', 'application audio',
                    'music domain', 'domain music', 'audio domain', 'domain audio',
                    'music field', 'field music', 'audio field', 'field audio',
                    'music area', 'area music', 'audio area', 'area audio',
                    'music technology', 'technology music', 'audio technology', 'technology audio',
                    'music computing', 'computing music', 'audio computing', 'computing audio',
                    'music science', 'science music', 'audio science', 'science audio',
                    'music engineering', 'engineering music', 'audio engineering', 'engineering audio',
                    
                    // Common meaningless tri-grams
                    'music information system', 'information music system', 'system music information',
                    'and audio retrieval', 'audio retrieval and', 'retrieval and audio',
                    'optical music', 'learning for', 'dataset for', 'music genre', 'classification using',
                    'music genre classification', 'music audio', 'music using',
                    
                    // Generic meaningless patterns
                    'for polyphonic', 'automatic music', 'automatic chord', 'music signals',  'and retrieval',
                    'representation for', 'and its',  'music emotion',  'for polyphonic music',  'the music',
                    'framework for',  'recognition using',  'techniques for',  'generation with',
                    'for music information',  'classification and',  'beat and',  'extraction from',  'segmentation and',
                    'genre classification using', 'for music classification', 'cover song'

                ]);

                // Clean and split text into words
                const words = text.toLowerCase()
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(word => word.length > 2);

                // Generate n-grams
                const ngrams = [];
                for (let i = 0; i <= words.length - n; i++) {
                    const ngram = words.slice(i, i + n);
                    const ngramText = ngram.join(' ');
                    
                    // Filter out n-grams that are all stop words
                    const hasNonStopWord = ngram.some(word => !stopWords.has(word));
                    
                    // Filter out meaningless n-grams
                    const isMeaningless = stopNGrams.has(ngramText);
                    
                    if (hasNonStopWord && !isMeaningless && ngram.every(word => word.length > 2)) {
                        ngrams.push(ngramText);
                    }
                }

                return ngrams;
            }

            extractKeywords(text) {
                // Extract both bi-grams and tri-grams
                const bigrams = this.extractNGrams(text, 2);
                const trigrams = this.extractNGrams(text, 3);
                
                // Combine and return all n-grams
                return [...bigrams, ...trigrams];
            }

            generateTagCloud() {
                // Extract n-grams from titles only
                const allNGrams = this.data.flatMap(paper => {
                    const titleNGrams = this.extractKeywords(paper.Title || '');
                    return titleNGrams;
                });

                // Count n-gram frequencies
                const ngramCounts = {};
                allNGrams.forEach(ngram => {
                    ngramCounts[ngram] = (ngramCounts[ngram] || 0) + 1;
                });

                // Get top n-grams (store more than we initially show)
                this.commonKeywords = Object.entries(ngramCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 60) // Store 60 total keywords
                    .map(([ngram]) => ngram);

                // Create tag cloud without pre-selecting tags
                this.updateScatterTagCloud();
                
                // Start with no tags selected
                this.selectedTags = new Set();
            }

            updateScatterTagCloud() {
                const tagCloud = document.getElementById('tagCloud');
                if (tagCloud && this.commonKeywords) {
                    const visibleKeywords = this.commonKeywords.slice(0, this.scatterTagsVisible);
                    const hasMore = this.commonKeywords.length > this.scatterTagsVisible;
                    
                    tagCloud.innerHTML = visibleKeywords
                        .map(keyword => `
                            <div class="tag" onclick="window.explorer.toggleTag('${keyword}')">
                                ${keyword}
                            </div>
                        `).join('') + 
                        (hasMore ? `
                            <div class="tag more-button" onclick="window.explorer.showMoreScatterTags()">
                                More... (+${this.commonKeywords.length - this.scatterTagsVisible})
                            </div>
                        ` : '');
                }
            }

            toggleTag(keyword) {
                // Fix tag selection by using a more reliable selector
                const tags = document.querySelectorAll('.tag');
                const tag = Array.from(tags).find(t => t.textContent.trim() === keyword);
                
                if (this.selectedTags.has(keyword)) {
                    this.selectedTags.delete(keyword);
                    tag?.classList.remove('selected');
                } else {
                    this.selectedTags.add(keyword);
                    tag?.classList.add('selected');
                }
                this.applyFilters();
            }

            resetFilters() {
                // Reset search inputs
                const titleSearch = document.getElementById('titleSearch');
                const authorSearch = document.getElementById('authorSearch');
                if (titleSearch) titleSearch.value = '';
                if (authorSearch) authorSearch.value = '';

                // Reset year sliders
                const yearStart = document.getElementById('yearStart');
                const yearEnd = document.getElementById('yearEnd');
                const yearStartValue = document.getElementById('yearStartValue');
                const yearEndValue = document.getElementById('yearEndValue');
                
                if (yearStart) {
                    yearStart.value = '2000';
                    yearStartValue.textContent = '2000';
                }
                if (yearEnd) {
                    yearEnd.value = '2024';
                    yearEndValue.textContent = '2024';
                }

                // Reset tag cloud visibility counters to defaults
                this.scatterTagsVisible = 10;
                this.evolutionTagsVisible = 30;

                // Reset scatter view tags
                this.selectedTags.clear();
                this.updateScatterTagCloud();

                // Reset evolution view to top 3 n-grams
                if (this.currentView === 'evolution') {
                    this.evolutionKeywords = new Set(this.commonKeywords.slice(0, 3));
                    this.createKeywordTrends();
                    this.updateEvolutionTagCloud();
                } else {
                    // Apply filters for scatter view (which will show all data)
                    this.applyFilters();
                }
            }

            applyFilters() {
                const titleSearch = document.getElementById('titleSearch')?.value.toLowerCase() || '';
                const authorSearch = document.getElementById('authorSearch')?.value.toLowerCase() || '';
                const yearStart = parseInt(document.getElementById('yearStart')?.value) || 2000;
                const yearEnd = parseInt(document.getElementById('yearEnd')?.value) || 2024;

                this.filteredData = this.data.filter(paper => {
                    // Apply title filter
                    if (titleSearch && !paper.Title?.toLowerCase().includes(titleSearch)) {
                        return false;
                    }

                    // Apply author filter
                    if (authorSearch && !paper.Authors?.toLowerCase().includes(authorSearch)) {
                        return false;
                    }

                    // Apply year filter
                    const year = parseInt(paper.Year);
                    if (year < yearStart || year > yearEnd) {
                        return false;
                    }

                    // Apply tag filters only if tags are selected
                    if (this.selectedTags.size > 0) {
                        const paperTitle = (paper.Title || '').toLowerCase();
                        return Array.from(this.selectedTags).some(tag => 
                            paperTitle.includes(tag.toLowerCase())
                        );
                    }

                    return true;
                });

                this.updatePlot();
            }

            switchView(viewType) {
                this.currentView = viewType;
                
                // Update view toggle buttons
                document.querySelectorAll('.view-option').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');

                // Show/hide appropriate views and controls
                if (viewType === 'scatter') {
                    document.getElementById('scatterView').style.display = 'block';
                    document.getElementById('evolutionView').style.display = 'none';
                    document.getElementById('scatterControls').style.display = 'block';
                    document.getElementById('evolutionControls').style.display = 'none';
                    this.updatePlot();
                } else if (viewType === 'evolution') {
                    document.getElementById('scatterView').style.display = 'none';
                    document.getElementById('evolutionView').style.display = 'block';
                    document.getElementById('scatterControls').style.display = 'none';
                    document.getElementById('evolutionControls').style.display = 'block';
                    this.generateEvolutionView();
                }
            }

            generateEvolutionView() {
                this.analyzeTopicEvolution();
                this.createKeywordTrends();
                this.setupEvolutionKeywordSelector();
                
                // Ensure initially selected keywords are marked as selected in the UI
                this.updateEvolutionKeywordSelection();
            }

            analyzeTopicEvolution() {
                // Group papers by year and analyze n-gram frequency over time
                const yearlyData = {};
                
                this.data.forEach(paper => {
                    const year = parseInt(paper.Year);
                    if (!yearlyData[year]) {
                        yearlyData[year] = [];
                    }
                    yearlyData[year].push(paper);
                });

                // Calculate n-gram frequencies per year
                this.topicEvolution = {};
                
                Object.entries(yearlyData).forEach(([year, papers]) => {
                    const yearNGrams = {};
                    
                    papers.forEach(paper => {
                        // Extract n-grams from titles only
                        const ngrams = this.extractKeywords(paper.Title || '');
                        
                        ngrams.forEach(ngram => {
                            if (this.commonKeywords.includes(ngram)) {
                                yearNGrams[ngram] = (yearNGrams[ngram] || 0) + 1;
                            }
                        });
                    });

                    // Calculate percentages
                    const totalPapers = papers.length;
                    Object.keys(yearNGrams).forEach(ngram => {
                        yearNGrams[ngram] = (yearNGrams[ngram] / totalPapers) * 100;
                    });

                    this.topicEvolution[year] = yearNGrams;
                });
            }

            createKeywordTrends() {
                if (this.evolutionKeywords.size === 0) {
                    // Show top 8 n-grams by default
                    const defaultNGrams = this.commonKeywords.slice(0, 3);
                    this.evolutionKeywords = new Set(defaultNGrams);
                }

                const years = Object.keys(this.topicEvolution).sort();
                const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
                
                const traces = Array.from(this.evolutionKeywords).map((ngram, index) => {
                    const values = years.map(year => 
                        this.topicEvolution[year][ngram] || 0
                    );

                    return {
                        x: years,
                        y: values,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: ngram,
                        line: { color: colors[index % colors.length], width: 2 },
                        marker: { size: 6 },
                        hovertemplate: `${ngram}: %{y:.1f}% in %{x}<extra></extra>`
                    };
                });

                const layout = {
                    title: {
                        text: 'Research Topic Trends Over Time',
                        font: { size: 16, color: '#333' }
                    },
                    margin: { l: 50, r: 50, t: 50, b: 50 },
                    xaxis: { title: 'Year' },
                    yaxis: { title: 'Percentage of Papers' },
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    legend: { orientation: 'h', y: -0.2 }
                };

                const config = {
                    responsive: true,
                    displayModeBar: false
                };

                Plotly.newPlot('keywordTrends', traces, layout, config);
            }

            setupEvolutionKeywordSelector() {
                this.updateEvolutionTagCloud();
            }

            updateEvolutionTagCloud() {
                const selector = document.getElementById('evolutionKeywordSelector');
                if (selector && this.commonKeywords) {
                    const visibleKeywords = this.commonKeywords.slice(0, this.evolutionTagsVisible);
                    const hasMore = this.commonKeywords.length > this.evolutionTagsVisible;
                    
                    selector.innerHTML = visibleKeywords
                        .map(ngram => {
                            // Check if this n-gram is currently selected
                            const isSelected = this.evolutionKeywords.has(ngram);
                            return `
                                <div class="tag ${isSelected ? 'selected' : ''}" 
                                     onclick="window.explorer.toggleEvolutionKeyword('${ngram}')">
                                    ${ngram}
                                </div>
                            `;
                        }).join('') + 
                        (hasMore ? `
                            <div class="tag more-button" onclick="window.explorer.showMoreEvolutionTags()">
                                More... (+${this.commonKeywords.length - this.evolutionTagsVisible})
                            </div>
                        ` : '');
                }
            }

            toggleEvolutionKeyword(ngram) {
                const tags = document.querySelectorAll('#evolutionKeywordSelector .tag');
                const tag = Array.from(tags).find(t => t.textContent.trim() === ngram);
                
                if (this.evolutionKeywords.has(ngram)) {
                    this.evolutionKeywords.delete(ngram);
                    tag?.classList.remove('selected');
                } else {
                    // Limit to 12 n-grams for better visualization
                    if (this.evolutionKeywords.size < 12) {
                        this.evolutionKeywords.add(ngram);
                        tag?.classList.add('selected');
                    } else {
                        // Show a brief message if limit reached
                        const label = document.querySelector('label[for="evolutionKeywords"]');
                        if (label) {
                            const originalText = label.textContent;
                            label.textContent = 'Maximum 12 topics selected - deselect one to add another';
                            label.style.color = '#f56565';
                            setTimeout(() => {
                                label.textContent = originalText;
                                label.style.color = '';
                            }, 2000);
                        }
                    }
                }
                
                this.createKeywordTrends();
            }

            updateEvolutionKeywordSelection() {
                // Update the visual selection state of evolution keywords
                const tags = document.querySelectorAll('#evolutionKeywordSelector .tag:not(.more-button)');
                tags.forEach(tag => {
                    const ngram = tag.textContent.trim();
                    if (this.evolutionKeywords.has(ngram)) {
                        tag.classList.add('selected');
                    } else {
                        tag.classList.remove('selected');
                    }
                });
            }

            showMoreScatterTags() {
                this.scatterTagsVisible = Math.min(this.scatterTagsVisible + 20, this.commonKeywords.length);
                this.updateScatterTagCloud();
                
                // Reapply selection states
                const tags = document.querySelectorAll('#tagCloud .tag:not(.more-button)');
                tags.forEach(tag => {
                    const keyword = tag.textContent.trim();
                    if (this.selectedTags.has(keyword)) {
                        tag.classList.add('selected');
                    }
                });
            }

            showMoreEvolutionTags() {
                this.evolutionTagsVisible = Math.min(this.evolutionTagsVisible + 20, this.commonKeywords.length);
                this.updateEvolutionTagCloud();
                
                // Reapply selection states
                this.updateEvolutionKeywordSelection();
            }

            async translateAbstract() {
                const targetLanguage = document.getElementById('targetLanguage').value;
                const translatedDiv = document.getElementById('translatedAbstract');
                
                // Get the full abstract from the stored instance variable
                const abstractText = this.currentPaperAbstract || '';
                
                if (!abstractText || abstractText === 'No abstract available') {
                    translatedDiv.innerHTML = '<div class="translate-loading">No abstract available to translate.</div>';
                    return;
                }
                
                // Show loading state
                translatedDiv.innerHTML = '<div class="translate-loading">Translating...</div>';
                
                try {
                    // Try multiple translation services for better reliability
                    let translatedText = null;
                    
                    // Determine text length and strategy
                    const isLongAbstract = abstractText.length > 500;
                    const textToTranslate = isLongAbstract ? abstractText.substring(0, 500) : abstractText;
                    
                    // First try: MyMemory API (has character limits)
                    try {
                        const myMemoryResponse = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=en|${targetLanguage}`);
                        const myMemoryData = await myMemoryResponse.json();
                        
                        if (myMemoryData.responseStatus === 200 && myMemoryData.responseData && myMemoryData.responseData.translatedText) {
                            translatedText = myMemoryData.responseData.translatedText;
                        }
                    } catch (e) {
                        console.log('MyMemory API failed, trying alternative...');
                    }
                    
                    // Second try: LibreTranslate (if available)
                    if (!translatedText) {
                        try {
                            const libreResponse = await fetch('https://libretranslate.de/translate', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    q: textToTranslate,
                                    source: 'en',
                                    target: targetLanguage,
                                    format: 'text'
                                })
                            });
                            const libreData = await libreResponse.json();
                            
                            if (libreData.translatedText) {
                                translatedText = libreData.translatedText;
                            }
                        } catch (e) {
                            console.log('LibreTranslate API failed');
                        }
                    }
                    
                    if (translatedText) {
                        translatedDiv.innerHTML = `
                            <div class="translated-text">
                                <strong>Translation (${this.getLanguageName(targetLanguage)}):</strong><br>
                                ${translatedText}
                                ${isLongAbstract ? `
                                    <div class="translation-disclaimer" style="border-left-color: #f59e0b; background: rgba(251, 191, 36, 0.1);">
                                        <strong> Note:</strong> This abstract was longer than 500 characters. Only the first 500 characters were translated due to API limitations. 
                                        <a href="https://translate.google.com/?sl=en&tl=${targetLanguage}&text=${encodeURIComponent(abstractText)}" target="_blank" style="color: #f59e0b; text-decoration: underline;">
                                            Click here to translate the full abstract with Google Translate
                                        </a>.
                                    </div>
                                ` : ''}
                                <div class="translation-disclaimer">
                                    <strong>âš ï¸ Disclaimer:</strong> This is an automatic translation. For academic precision, consider reaching out to the authors.
                                </div>
                            </div>
                        `;
                    } else {
                        throw new Error('All translation services unavailable');
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    
                    // Create a direct Google Translate link with the abstract pre-filled
                    const googleTranslateUrl = `https://translate.google.com/?sl=en&tl=${targetLanguage}&text=${encodeURIComponent(abstractText)}`;
                    
                    translatedDiv.innerHTML = `
                        <div class="translated-text translation-fallback">
                            <strong>ðŸ”— Translation Service:</strong><br>
                            Translation services are currently unavailable. Click the button below to translate this abstract using Google Translate:
                            <br><br>
                            <a href="${googleTranslateUrl}" target="_blank" class="fallback-button">
                                ðŸŒ Open in Google Translate
                            </a>
                            <div class="copy-section">
                                <details>
                                    <summary>ðŸ“‹ Copy Abstract Text</summary>
                                    <div class="copy-text-area">
                                        ${abstractText}
                                    </div>
                                </details>
                            </div>
                        </div>
                    `;
                }
            }

            getLanguageName(code) {
                const languages = {
                    'es': 'Spanish', 'zh': 'Chinese (Mandarin)', 'hi': 'Hindi', 'ar': 'Arabic',
                    'pt': 'Portuguese', 'bn': 'Bengali', 'ur': 'Urdu', 'id': 'Indonesian',
                    'sw': 'Swahili', 'te': 'Telugu', 'mr': 'Marathi', 'ta': 'Tamil',
                    'tr': 'Turkish', 'vi': 'Vietnamese', 'th': 'Thai', 'gu': 'Gujarati',
                    'fa': 'Persian (Farsi)', 'ms': 'Malay', 'kn': 'Kannada', 'ml': 'Malayalam',
                    'pa': 'Punjabi', 'or': 'Odia', 'as': 'Assamese', 'ne': 'Nepali',
                    'si': 'Sinhala', 'my': 'Myanmar (Burmese)', 'km': 'Khmer (Cambodian)',
                    'lo': 'Lao', 'am': 'Amharic', 'ha': 'Hausa', 'fr': 'French', 'de': 'German',
                    'it': 'Italian', 'nl': 'Dutch', 'sv': 'Swedish'
                };
                return languages[code] || code.toUpperCase();
            }

            toggleAbstract() {
                const truncatedSpan = document.getElementById('abstractTruncated');
                const fullSpan = document.getElementById('abstractFull');
                const button = document.querySelector('.show-more-btn');
                
                if (!truncatedSpan || !fullSpan || !button) return;
                
                const isExpanded = fullSpan.style.display !== 'none';
                
                if (isExpanded) {
                    // Collapse: hide full text, show truncation
                    fullSpan.style.display = 'none';
                    truncatedSpan.style.display = 'inline';
                    button.innerHTML = 'Show full abstract';
                } else {
                    // Expand: show full text, hide truncation
                    fullSpan.style.display = 'inline';
                    truncatedSpan.style.display = 'none';
                    button.innerHTML = 'Show less';
                }
            }
        }

        // Create the explorer instance when the script loads
        window.explorer = new ISMIRExplorer();

        // Initialize only after DOM is fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.explorer.init();
            });
        } else {
            window.explorer.init();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const plotDiv = document.getElementById('plotDiv');
            if (plotDiv && plotDiv.data) {
                Plotly.Plots.resize('plotDiv');
            }
        });
    </script>
</body>
</html>